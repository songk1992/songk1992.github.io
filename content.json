{"pages":[{"title":"About Me","text":"Resume Song Hyun Kim Interests Meeting People Photography Design Programming Computer Science Skills fluent in Korean fluent in English Frontend Web Backend Web through Spring Web Design with HTML & CSS Python C, C++, C#, JAVA BigData + AI etc Education Monte Kelly (Kelly College UK) GCSE GCE(AAAAB) (2008 ~ 2012) 고려사이버대학교 소프트웨어공학과 The Cyber University of Korea (Software Engineering) (2016 ~ 2018) 국립서울과학기술대학교 컴퓨터공학과 Seoul National University of Science and Technology (Computer Science) (2019 ~ 2020) Experience Completed military service as sergeant(2014) Medical Enzyme Therapy Maintainer(2015) December Hotel Floor Manager(2016) MediaWill Jeju SalesAgent(2017) Marriott Jeju Resort Concierge + Bell(2017) Hyundai Construction Equipment OEM Factory(2018) Wedding Hall Museum Waiter(2019) KTCS Telemarketer(2020) etc Song Hyun Kim","link":"/about/index.html"},{"title":"resume","text":"Resume Song Hyun Kim Interests Meeting People Photography Design Programming Computer Science Skills fluent in Korean fluent in English Frontend Web Backend Web through Spring Web Design with HTML & CSS Python C, C++, C#, JAVA BigData + AI etc Education Monte Kelly (Kelly College UK) GCSE GCE(AAAAB) (2008 ~ 2012) &lt;/a&gt; &lt;!--Link--&gt; &lt;a href=&quot;http://www.cuk.edu/&quot;&gt; &lt;li&gt;고려사이버대학교&lt;br&gt; 소프트웨어공학과&lt;br&gt; The Cyber University of Korea&lt;br&gt; (Software Engineering)&lt;br&gt; (2016 ~ 2018)&lt;br&gt;&lt;br&gt; &lt;/li&gt; &lt;/a&gt; &lt;a href=&quot;https://www.seoultech.ac.kr/&quot;&gt; &lt;li&gt;국립서울과학기술대학교&lt;br&gt; 컴퓨터공학과&lt;br&gt; Seoul National University of Science and Technology&lt;br&gt; (Computer Science)&lt;br&gt; (2019 ~ 2020)&lt;br&gt; &lt;/li&gt; &lt;/a&gt; Experience Completed military service as sergeant(2014) Medical Enzyme Therapy Maintainer(2015) December Hotel Floor Manager(2016) MediaWill Jeju SalesAgent(2017) Marriott Jeju Resort Concierge + Bell(2017) Hyundai Construction Equipment OEM Factory(2018) Wedding Hall Museum Waiter(2019) KTCS Telemarketer(2020) etc Extracurriculars Song Hyun Kim","link":"/resume/index.html"}],"posts":[{"title":"백준 자바 1158 알고리즘 &#39;요세푸스 문제&#39; 문제풀이","text":"코드를 보다보니 어느새 새벽이 되었네요.새벽에 우는 귀뚜라미? 소리를 들으며 가을의 바람을 느껴봅니다선선한 바람을 맞으며 푸는 코드링크드리스트(Linked List) 문제를 배열없이 Linked List를 이용해 풀었습니다.원형 링크드리스트(Circular Linked List) 문제입니다. 코드 설명코드만 봐도 쉽게 이해 할수 있게 객체 지향적으로 작성되었으며코드 사용시 출처 링크를 남겨주시면 감사하겠습니다.백준 1158번 문제 링크More info: 요세푸스 문제자바는 여기서 배웠습니다More info: 유데미 강좌(영어)/자바강의링크드리스트 및 자료구조의 경우 아래에서 배웠습니다More info: 유데미 강좌(영어)/자바자료구조 알고리즘 간단한 노트 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176/*Made by SONG KIM2020-10-03 */import java.util.Scanner;public class Main { public static class Node { int data; Node next; Node previous; public void displayNode(){ System.out.println(data); } } public static class CustomLinkedList { Node first; Node last; public CustomLinkedList() { this.first = null; this.last = null; } public void InsertFirst(int data){ Node newNode = new Node(); newNode.data = data; if(IsEmpty()) { last = newNode; }else { first.previous = newNode; } newNode.next = first; this.first = newNode; last.next = newNode; newNode.previous = last; } public boolean IsEmpty(){ return first == null; } public void DisplayAll(){ System.out.print(&quot;&lt;&quot;); Node temp = new Node(); temp = last; Node newNode = new Node(); newNode = first; if(IsEmpty()!=true) { while (temp.data != newNode.data) { System.out.print(temp.data); System.out.print(&quot;, &quot;); temp = temp.previous; } System.out.print(temp.data); System.out.print(&quot;&gt;&quot;); } } public int Josephus(int sn, int d){ int counter = 1; // start from where data = sn Node newNode = new Node(); newNode = last; if(IsEmpty()) { return 0; }// System.out.println();// System.out.println(&quot;first + last&quot;);// System.out.println(first.data);// System.out.println(last.data);// System.out.println(); while (newNode.data != sn){ newNode = newNode.previous; } // find data with d distance away while (counter != d){ newNode = newNode.previous; ++counter; } // print number being deleted System.out.print(newNode.data); // allocate next number sn = newNode.previous.data; // delete corresponding Node // when newNode is last if(newNode == last){ newNode.next.previous = newNode.previous; newNode.previous.next = newNode.next; last = newNode.previous; }else { newNode.next.previous = newNode.previous; } // when newNode is first if(newNode == first){ newNode.next.previous = newNode.previous; newNode.previous.next = newNode.next; first = newNode.next; }else { newNode.previous.next = newNode.next; } return sn; } } public static void main(String[] args) throws Exception { CustomLinkedList cll = new CustomLinkedList(); Scanner sc = new Scanner(System.in); // Number of Elements in the list int N = sc.nextInt(); // Number of Elements to be jumped int K = sc.nextInt(); // Initialize List with consecutive order for (int i = 1; i &lt;= N; i++) { cll.InsertFirst(i); } // show all elements //cll.DisplayAll(); // Starting number int sn = 1; //Josephus Problem System.out.print(&quot;&lt;&quot;); for (int i = 0; i&lt;N; i++){ //cll.DisplayAll(); //System.out.println(); sn = cll.Josephus(sn, K); if (i == N-1)break; System.out.print(&quot;, &quot;); } System.out.print(&quot;&gt;&quot;); }} 글을 마치며인간은 뛰어넘은 역경의 숫자만큼 강해진다. 인간은 뛰어넘은 역경의 숫자만큼 강해진다. 그 숫자가 많으면 많을수록, 어떠한 상황에서도 지지 않는 강한 사람이 된다. 그러니까 인생에서 성공하는 사람이 된다는 것은 역경을 많이 극복한다는 것과 같은 뜻이기도 하다. &lt;기타가와 야스시, ‘편지가게’&gt; 모두들 화이팅 하셔서 훌륭한 프로그래머가 되시길 바라겠습니다.","link":"/2020/10/03/%EB%B0%B1%EC%A4%80-%EC%9E%90%EB%B0%94-1158-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9A%94%EC%84%B8%ED%91%B8%EC%8A%A4-%EB%AC%B8%EC%A0%9C-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/09/01/hello-world/"},{"title":"백준 자바 2346 알고리즘 풍선 터뜨리기 문제&#39; 문제풀이","text":"풍선 터트리기 백준 2346번 문제는전에 풀었던 요세푸스 문제와 매우 유사합니다링크드리스트(Linked List) 문제이며.배열없이 Linked List를 이용해 풀었습니다.원형 링크드리스트(Circular Linked List) 문제입니다. 백준 1158번 문제 링크More info: 요세푸스 문제 코드 설명코드만 봐도 쉽게 이해 할수 있게 객체 지향적으로 작성되었으며코드 사용시 출처 링크를 남겨주시면 감사하겠습니다.백준 2346번 문제 링크More info: 풍선 터뜨리기 문제자바는 여기서 배웠습니다More info: 유데미 강좌(영어)/자바강의링크드리스트 및 자료구조의 경우 아래에서 배웠습니다More info: 유데미 강좌(영어)/자바자료구조 알고리즘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/*Made by SONG KIM2020-10-03 */import java.util.Scanner;public class Main { static int ValueBeingRemoved = 1; public static class Node { int data_row; Node next; Node previous; public void displayNode_data_row(){ System.out.print(data_row); } } public static class CustomLinkedList { Node first; Node last; public CustomLinkedList() { this.first = null; this.last = null; } // 풍선 값을 입력 및 정렬 public void InsertFirst(int data_row){ Node newNode = new Node(); newNode.data_row = data_row; if(IsEmpty()) { last = newNode; }else { first.previous = newNode; } newNode.next = first; this.first = newNode; last.next = newNode; newNode.previous = last; } // 풍선이 비어있는지 확인 public boolean IsEmpty(){ return first == null; } // 풍선 정보 출력 public void DisplayAll(){ Node temp = new Node(); temp = last; Node newNode = new Node(); newNode = first; if(IsEmpty()!=true) { while (temp.data_row != newNode.data_row) {// System.out.print(temp.data_row);// System.out.print(&quot; &quot;); temp = temp.previous; }// System.out.print(temp.data_row);// System.out.println(); } } public int Balloon(int sn, int d){ int counter = 0; // 처음에는 1을 없앤다 if (sn == 1) { counter = d; } // start from where data = sn Node newNode = last; if(IsEmpty()) { return 0; }// System.out.println();// System.out.println(&quot;first + last&quot;);// System.out.println(first.data);// System.out.println(last.data);// System.out.println(); while (newNode.data_row != sn){ newNode = newNode.previous; } //System.out.println(&quot;d : &quot;+ d); // find data with d distance away if(counter &gt; d){ while (counter &gt; d){ newNode = newNode.next; //System.out.println(&quot;counter : &quot; + counter + &quot; newNode : &quot; + newNode.data_row); counter--; } } else if(counter &lt; d){ while (counter &lt; d-1){ newNode = newNode.previous; //System.out.println(&quot;counter : &quot; + counter + &quot; newNode : &quot; + newNode.data_row); counter++; } }// if(d == 0){// System.out.println(&quot;0은 적혀있지 않음&quot;);// } // print number being deleted// System.out.println(); ValueBeingRemoved = newNode.data_row; System.out.print(ValueBeingRemoved);// System.out.println(); // allocation dData// System.out.println();// System.out.print(&quot;dData : &quot; + newNode.dData);// System.out.println(); // allocate next number sn = newNode.previous.data_row; // delete corresponding Node // when newNode is last if(newNode == last){ newNode.next.previous = newNode.previous; newNode.previous.next = newNode.next; last = newNode.previous; }else { newNode.next.previous = newNode.previous; } // when newNode is first if(newNode == first){ newNode.next.previous = newNode.previous; newNode.previous.next = newNode.next; first = newNode.next; }else { newNode.previous.next = newNode.next; } return sn; } } public static void main(String[] args) throws Exception { CustomLinkedList cll = new CustomLinkedList(); Scanner sc = new Scanner(System.in); // Number of Elements in the list int N = sc.nextInt(); // Directional Data int [] paperNumbers = new int[N+1]; // Initialize List with consecutive order for (int i = 1; i &lt;= N; i++) { // Directional Data paperNumbers[i] = sc.nextInt(); cll.InsertFirst(i); } // show all elements // cll.DisplayAll(); // Starting number int sn = 1; //balloon Problem for (int i = 0; i&lt;N; i++){ //System.out.println(); //cll.DisplayAll(); //System.out.println(); //System.out.println(&quot;sn :&quot; + sn); sn = cll.Balloon(sn, paperNumbers[ValueBeingRemoved]); if (i == N-1)break; System.out.print(&quot; &quot;); } }} 글을 마치며인간은 뛰어넘은 역경의 숫자만큼 강해진다. 인간은 뛰어넘은 역경의 숫자만큼 강해진다. 그 숫자가 많으면 많을수록, 어떠한 상황에서도 지지 않는 강한 사람이 된다. 그러니까 인생에서 성공하는 사람이 된다는 것은 역경을 많이 극복한다는 것과 같은 뜻이기도 하다. &lt;기타가와 야스시, ‘편지가게’&gt; 오늘하루도 즐거운 하루 되세요~","link":"/2020/10/03/%EB%B0%B1%EC%A4%80-%EC%9E%90%EB%B0%94-2346-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%92%8D%EC%84%A0-%ED%84%B0%EB%9C%A8%EB%A6%AC%EA%B8%B0-%EB%AC%B8%EC%A0%9C-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"},{"title":"백준자바 1021 알고리즘 &#39;회전하는큐&#39; 문제풀이","text":"오늘도 상쾌한 마음으로 백준 문제를 풀었습니다.링크드리스트(Linked List) 문제를 배열없이 Linked List를 이용해 풀었습니다. 코드 설명코드만 봐도 쉽게 이해 할수 있게 객체 지향적으로 작성되었으며코드 사용시 출처 링크를 남겨주시면 감사하겠습니다.백준 1021번 문제 링크More info: 회전하는 큐자바는 여기서 배웠습니다More info: 유데미 강좌(영어)/자바강의링크드리스트 및 자료구조의 경우 아래에서 배웠습니다More info: 유데미 강좌(영어)/자바자료구조 알고리즘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/*Made by SONG KIM2020-10-02 */import java.util.Scanner;public class Main { public static class Node { int data; Node next; Node previous; public void displayNode(){ System.out.println(&quot;{ &quot; + data + &quot; }&quot; ); } } public static class CustomLinkedList { Node first; Node last; public CustomLinkedList() { this.first = null; this.last = null; } public void InsertFirst(int data){ Node newNode = new Node(); newNode.data = data; if(IsEmpty()) { last = newNode; }else { first.previous = newNode; } newNode.next = first; this.first = newNode; } public void InsertLast(int data){ Node newNode = new Node(); newNode.data = data; if(IsEmpty()) { first = newNode; }else { last.next = newNode; } newNode.previous = last; this.last = newNode; } public Node DeleteFirstNode(){ Node temp = first; if(first.next == null){ last = null; }else { first.next.previous = null; } first = first.next; return temp; } public boolean IsEmpty(){ return (first == null); } //앞쪽 부터 몇번 리스트를 움직여야 해당 숫자를 없애는지 체크크 public int StepsFromFirst(int data){ int k = 0; Node Current = first; while (Current != null) { if(Current.data == data) { return k; } Current = Current.next; k++; } return k; } //given List is not empty; public void RearrangeListToHaveDataFirst(int data){ Node Current = first; while (Current != null){ if(Current.data == data){ break; } // DeleteFirstNode if(first.next == null){ last = null; }else { first.next.previous = null; } first = first.next; // InsertLast Node newNode = new Node(); newNode.data = Current.data; if(IsEmpty()) { first = newNode; }else { last.next = newNode; } newNode.previous = last; this.last = newNode; // Current = Current.next; } } public void displayForward(){ System.out.println(&quot;List (first --&gt; last) &quot;); Node Current = first; while (Current != null){ Current.displayNode(); Current = Current.next; } System.out.println(); } } public static void main(String[] args) throws Exception { CustomLinkedList cll = new CustomLinkedList(); Scanner sc = new Scanner(System.in); // Number of Elements in the list int N = sc.nextInt(); // Number of Elements to be removed int M = sc.nextInt(); // Initialize List with consecutive order for(int i =N;i&gt;0;i--){ cll.InsertFirst(i); } //cll.displayForward(); // Count steps 2 and 3 int counter = 0; for(int i=0;i&lt;M;i++){ // Element to be removed int a = sc.nextInt(); // Number of steps from the First element int k = cll.StepsFromFirst(a); if((N-i-k) &gt; k){ counter += k; }else{ counter += (N-i-k); } cll.RearrangeListToHaveDataFirst(a); cll.DeleteFirstNode(); //cll.displayForward(); } System.out.println(counter); }} 글을 마치며인간은 뛰어넘은 역경의 숫자만큼 강해진다. 인간은 뛰어넘은 역경의 숫자만큼 강해진다. 그 숫자가 많으면 많을수록, 어떠한 상황에서도 지지 않는 강한 사람이 된다. 그러니까 인생에서 성공하는 사람이 된다는 것은 역경을 많이 극복한다는 것과 같은 뜻이기도 하다. &lt;기타가와 야스시, ‘편지가게’&gt; 모두들 화이팅 하셔서 훌륭한 프로그래머가 되시길 바라겠습니다.","link":"/2020/10/02/%EB%B0%B1%EC%A4%80%EC%9E%90%EB%B0%94-1021-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%9A%8C%EC%A0%84%ED%95%98%EB%8A%94%ED%81%90-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"},{"title":"백준 자바 2805 알고리즘 &#39;나무 자르기 문제&#39; 문제풀이","text":"날씨가 많이 쌀쌀해졌군요 추운 날씨속에 학교 앞 자취방에서 코딩을 해봅니다. 코드 설명코드만 봐도 쉽게 이해 할수 있게 객체 지향적으로 작성되었으며코드 사용시 출처 링크를 남겨주시면 감사하겠습니다.백준 2805번 문제 링크More info: 나무자르기 문제자바는 여기서 배웠습니다More info: 유데미 강좌(영어)/자바강의링크드리스트 및 자료구조의 경우 아래에서 배웠습니다More info: 유데미 강좌(영어)/자바자료구조 알고리즘 첫번째 시도 (시간초과로 틀림)Procedure findMaxH(long[] a, long p, long r, Long m) Inputs : - a : the array to search in - p : the value we are searching for in a(min) m의 촤소값 - r : the value we are searching for in a(max) m의 최대값 - m : the value we are searching for in a(equal) 잘라야하는 나무의 값 Outputs : - 잘라야하는 나무 산출량의 최대 높이 최소값을 0, 최대값을 나무의 최대크기로 정한다. 최소값 + 최대값의 평균값인 q를 구한다. q 값일때 나무 산출량을 H를 ValueOfTreeOutput을 통해 구한다.a) H가 m 보다 크면 최소값을 q+1로 수정한다b) H가 m 보다 작으면 최대값을 q-1로 수정한다c) H와m이 같다면 q를 반환한다. recursive 재귀적으로 돌린다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = sc.nextInt(); Long M = sc.nextLong(); long a[] = new long[N]; long maxLength = 0; for(int i = 0; i&lt;N; i++){ //Tree length a[i] = sc.nextLong(); maxLength = Math.max(a[i],maxLength); } System.out.println(findMaxH(a, 0, maxLength, M)); } private static long findMaxH(long[] a, long p, long r, Long m) { long q = (p+r)/2; long H = ValueOfTreeOutput(a, q); if (H &gt; m){ return findMaxH(a,q+1,r,m); } else if (H &lt; m){ return findMaxH(a,p,q-1,m); } else{ return q; } } private static long ValueOfTreeOutput(long[] a, Long H) { long sum = 0; for(int i = 0; i&lt;a.length; i++){ long temp = a[i] - H; if(temp &gt; 0){ sum += temp; } } return sum; }} n번째 시도 (성공) 위에 코드에서 자바 배열을 오름차순으로 정렬 1Arrays.sort(a); 재귀문 삭제 While 문 사용을 통해 시간을 줄였습니다 기본적인 틀은 binary search를 사용한다는 점에서 같습니다 문제에서 제시된 값이 매우 크기 때문에 조그마한 차이도 크게 느껴지는것 같습니다 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Arrays;import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int M = sc.nextInt(); int []a = new int[N]; for(int i = 0; i&lt;N; i++){ //Tree lengths a[i] = sc.nextInt(); } Arrays.sort(a); // 자바 배열을 오름차순으로 정렬 int p = 1; int q; int r = a[N-1]; long CalculatedOutPut = 0; long GivenOutPut = M; while (p &lt;= r) { q = (p + r)/2; CalculatedOutPut = 0; for(int i = 0; i&lt;N; i++){ if(a[i] &gt;= q){ CalculatedOutPut += (a[i] - q); } } if(CalculatedOutPut &gt;= GivenOutPut){ p = q + 1; } else if(CalculatedOutPut &lt; GivenOutPut){ r = q - 1; } } System.out.println(r); } } 글을 마치며인간은 뛰어넘은 역경의 숫자만큼 강해진다. 인간은 뛰어넘은 역경의 숫자만큼 강해진다. 그 숫자가 많으면 많을수록, 어떠한 상황에서도 지지 않는 강한 사람이 된다. 그러니까 인생에서 성공하는 사람이 된다는 것은 역경을 많이 극복한다는 것과 같은 뜻이기도 하다. &lt;기타가와 야스시, ‘편지가게’&gt; 모두들 화이팅 하셔서 훌륭한 프로그래머가 되시길 바라겠습니다.","link":"/2020/10/04/%EB%B0%B1%EC%A4%80-%EC%9E%90%EB%B0%94-2805-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%82%98%EB%AC%B4-%EC%9E%90%EB%A5%B4%EA%B8%B0-%EB%AC%B8%EC%A0%9C-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"}],"tags":[{"name":"백준","slug":"백준","link":"/tags/%EB%B0%B1%EC%A4%80/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"linked list","slug":"linked-list","link":"/tags/linked-list/"},{"name":"binary search","slug":"binary-search","link":"/tags/binary-search/"}],"categories":[{"name":"백준","slug":"백준","link":"/categories/%EB%B0%B1%EC%A4%80/"},{"name":"java","slug":"백준/java","link":"/categories/%EB%B0%B1%EC%A4%80/java/"},{"name":"linked list","slug":"백준/java/linked-list","link":"/categories/%EB%B0%B1%EC%A4%80/java/linked-list/"},{"name":"binary search","slug":"백준/java/binary-search","link":"/categories/%EB%B0%B1%EC%A4%80/java/binary-search/"}]}